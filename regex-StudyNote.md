# 正则表达式 regex



### 特殊字符

![image-20220818145947435](https://cdn.staticaly.com/gh/zhenghang1/Image@main/img/image-20220818145947435.png)

+ `()`

  表示其内部是一个子表达式

+ `[]`

  表示一个范围表达式，可以与其内部所有出现的符号的其中一个匹配，其中

  + 连续的字符可用`-`进行简写，如：`[A-Z]`
  + 若在`[]`的最开始有`^`符，表示取反，与不在中括号中的符号进行匹配

+ `{}`

  限定符的标志，详见下面限定符的内容



### 限定符

限定符用来限定某个语句的匹配数目，**出现在范围表达式之后**，主要有六种，如下：

| 限定符  |                             含义                             |
| :-----: | :----------------------------------------------------------: |
|   `*`   | 匹配前面的子表达式零次或多次。例如，`zo* `能匹配 "z" 以及 "zoo"。 |
|   `+`   | 匹配前面的子表达式一次或多次。例如，`zo+ `能匹配 **"zo"** 以及 "**zoo"**，但不能匹配 **"z"**。 |
|   `?`   | 匹配前面的子表达式零次或一次。例如，`do(es)?` 可以匹配 **"do"** 、 **"does"**中的 **"do"** |
|  `{n}`  |               n 是一个非负整数。匹配确定的n次                |
| `{n,}`  |                n 是一个非负整数。至少匹配n次                 |
| `{n,m}` | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次 |

注意，`*`和`+`表达式都是贪婪的，进行最大匹配，若要使其进行最小匹配，可以在其后面加上`?`符号，如：
~~~
<h1>header</h1>	

<.*>:会匹配整个语句<h1>header</h1>	
<.*?>:只会匹配第一个<h1>
~~~



### 非打印字符

![image-20220818152119668](https://cdn.staticaly.com/gh/zhenghang1/Image@main/img/image-20220818152119668.png)

其中较为常用的有`\s`,`\S`，此外还有：

+ `\w`匹配所有的字母、数字和下划线，等价于` [A-Za-z0-9_]`，`\W`匹配所有的非字母、数字和下划线，等价于` [^A-Za-z0-9_]`
+ `\d`匹配一个数字字符，等价于` [0-9]`，`\D`匹配一个非数字字符，等价于`[^0-9]`



### 定位符

定位符可以限定匹配进行的位置，不在对应位置处的内容不会进行匹配，主要有以下四个

![image-20220818152710411](https://cdn.staticaly.com/gh/zhenghang1/Image@main/img/image-20220818152710411.png)

其中`^`和`$`较为常用，而`\b`的使用位置很重要：使用`\b`可以用来匹配单词开头或者单词的结尾，如：`\bCha`匹配以Cha开头的单词，`ter\b`匹配以ter结尾的单词；而`\B`可用来匹配不在开头或结尾的单词



### 分组和捕获

圆括号`()`表示子表达式，且一个圆括号内可以使用`|`符号放入多个可选的子表达式，注意**和中括号`[]`区分开**，中括号内是可选的字符而不是表达式，且不需要使用`|`符号分开

采用圆括号的子表达式完成匹配后，会进行“捕获”，即对子表达式的内容进行存储，在正则表达式中可以使用`\n`进行指代，n是整数（索引从1开始），相当于用已匹配的第n组的具体内容替换掉“\n”（注意，n最大到99）

有些时候我们**不想让某个子表达式被捕获**（如在捕获和输出分开的情境下，我们不愿意既要修改正则表达式又要修改输出的索引，想要让中间新增的子表达式不纳入捕获），可以使用**非捕获元**符号
有三组非捕获元：

+ `?:`：单纯的表示非捕获的意思，除此之外无其他作用，用法：`(?:exp)`，表匹配exp但是不进行捕获

+ `?=`和`?<=`：正向预查（`=`表示有该表达式）

  + `exp1(?=exp2)`，查找exp2前面的exp1，其中exp2起条件作用，不参与匹配（即匹配结果中不含exp2，可理解为exp2就是个匹配条件，限制exp1的匹配），并且下一步匹配从exp2开始继续进行，eg：

    ~~~shell
    [0-9a-z]{2}(?=aa)	#匹配两位字母或数字，且其后面需紧跟aa
    
    待匹配文本：12332aa438aaf
    匹配结果：32 38
    
    待匹配文本：aaaaaaaa
    匹配结果：aa aa aa	#匹配完第一组后，是从第三个a继续开始匹配
    ~~~

  + `(?<=exp2)exp1`，查找前面是exp2的exp1，类似`?=`，不加赘述

+ `?!`和`?<!`：负向预查（`!`表示没有该表达式）

  + `exp1(?!exp2)`，查找后面不是exp2的exp1
  + `(?<!exp2)exp1`，查找前面不是exp2的exp1



### 修饰符

> 正则表达式的修饰符，也称为“标记”，用来指定额外的匹配策略，其并不属于表达式，而是写在表达式外面

![image-20220818212618042](https://cdn.staticaly.com/gh/zhenghang1/Image@main/img/image-20220818212618042.png)

修饰符写于表达式后面，写法：`/pattern/flags` 

+ `i`修饰符：不区分大小写
+ `g`修饰符：不加`g`的情况下，正则表达式只匹配第一个匹配项；加上`g`后匹配所有的匹配项
+ `m`修饰符：不加`m`的情况下，多行文本中，若需匹配`^`和`$`，正则表达式只在第一行中进行匹配；加上`m`后会在每一行中都进行匹配
+ `s`修饰符：不加`s`的情况下，`.`匹配除换行符之外的所有符号；加上`s`后，`.`匹配包括换行符在内的所有符号



### 练习和示例

详见[这里](https://www.runoob.com/regexp/regexp-example.html)